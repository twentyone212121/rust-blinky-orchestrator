# Task: Zephyr RTOS & Rust Integration Orchestrator

## Objective

This task evaluates your proficiency with modern RTOS development, the emerging Rust
ecosystem in embedded systems, and your ability to automate hardware toolchains using
Python. You will demonstrate a complete lifecycle from C-based firmware to Rust-based
implementation and final automation.

## Requirements

1. Zephyr RTOS Baseline (C/C++)
   - Environment Setup: Follow the official Zephyr Ge≈µing Started Guide to initialize a
     workspace.
   - Build & Flash: Compile the standard simple_blinky sample for the provided NXP board.
   - Demonstration: Successfully flash the binary and demonstrate the onboard LED blinking
     as expected.
2. Rust Integration
   - Language Migration: Follow the Zephyr Rust Documentation to configure a Rust-based
     environment within the Zephyr ecosystem.
   - Implementation: Replicate the blinky functionality using Rust source code.
   - Verification: Compile and program the NXP board to demonstrate a functional blinky
     light parity between C and Rust.
3. Python Orchestration Tool
   - Framework: Write a Python-based orchestrator that utilizes the west meta-tool
     framework.
   - Automation: The script must programmatically execute the west build and west flash
     commands for both the C and Rust versions.
   - Telemetry & Logging: Capture and store all command-line outputs (STDOUT/STDERR)
     into organized log files or a structured database (e.g., JSON or SQLite) for audit
     purposes.

## Submission Guidelines

Please provide a link to a GitHub repository containing:

- Source Code: The Rust implementation and the Python orchestrator script.
- README.md: Your primary documentation hub including:
  - Setup Instructions: How to configure the Zephyr environment and Rust toolchain.
  - Architecture Diagram: A brief overview of how the Python orchestrator interacts
    with the west framework and the filesystem.
  - Execution Guide: Specific commands to run your Python script to trigger the full
    build/flash cycle.
- Logs: Sample output files generated by your orchestrator during a successful run.

## Evaluation Criteria

- Toolchain Proficiency: Correct usage of west, Zephyr modules, and the Rust compiler
  for embedded targets.
- Automation Quality: The Python orchestrator should handle subprocesses cleanly and
  manage errors (e.g., build failures or board disconnects) gracefully.
- Technical Accuracy: The ability to transition between C and Rust while maintaining
  hardware-level functionality.
- Code Cleanliness: We prioritize idiomatic code in all three languages (C/Rust/Python).
